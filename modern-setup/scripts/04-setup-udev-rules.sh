#!/bin/bash
#
# 04-setup-udev-rules.sh - Устанавливает udev правила для автоматической настройки модемов
# Может запускаться повторно - проверяет существование перед установкой
#

set -e

SCRIPT_NAME="04-setup-udev"
UDEV_RULES_FILE="/etc/udev/rules.d/99-modem-interfaces.rules"
HELPER_SCRIPT="/usr/local/bin/modem-interface-handler.sh"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
HELPER_SOURCE="${SCRIPT_DIR}/../helpers/modem-interface-handler.sh"

# Цвета для вывода
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[${SCRIPT_NAME}]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[${SCRIPT_NAME}]${NC} $1"
}

log_error() {
    echo -e "${RED}[${SCRIPT_NAME}]${NC} $1"
}

check_root() {
    if [ "$(id -u)" != "0" ]; then
        log_error "Этот скрипт должен быть запущен с правами root"
        exit 1
    fi
}

# Установка helper скрипта
install_helper_script() {
    if [ ! -f "$HELPER_SOURCE" ]; then
        log_error "Helper скрипт не найден: $HELPER_SOURCE"
        exit 1
    fi

    log_info "Установка helper скрипта..."

    if [ -f "$HELPER_SCRIPT" ]; then
        # Создаём бэкап
        local backup="${HELPER_SCRIPT}.backup.$(date +%s)"
        cp "$HELPER_SCRIPT" "$backup"
        log_warn "Создан бэкап существующего скрипта: $backup"
    fi

    cp "$HELPER_SOURCE" "$HELPER_SCRIPT"
    chmod +x "$HELPER_SCRIPT"

    log_info "Helper скрипт установлен: $HELPER_SCRIPT"
}

# Создание udev правил
create_udev_rules() {
    log_info "Создание udev правил..."

    if [ -f "$UDEV_RULES_FILE" ]; then
        local backup="${UDEV_RULES_FILE}.backup.$(date +%s)"
        cp "$UDEV_RULES_FILE" "$backup"
        log_warn "Создан бэкап существующих правил: $backup"
    fi

    cat > "$UDEV_RULES_FILE" << 'EOF'
# Udev rules for automatic modem interface configuration
# Auto-generated by modern-setup

# Правила для eth интерфейсов (eth1-eth20)
# Срабатывают при появлении/удалении интерфейса и при получении IP-адреса

# При добавлении интерфейса eth1-eth20
SUBSYSTEM=="net", ACTION=="add", KERNEL=="eth[1-9]", RUN+="/usr/local/bin/modem-interface-handler.sh add $kernel"
SUBSYSTEM=="net", ACTION=="add", KERNEL=="eth1[0-9]", RUN+="/usr/local/bin/modem-interface-handler.sh add $kernel"
SUBSYSTEM=="net", ACTION=="add", KERNEL=="eth20", RUN+="/usr/local/bin/modem-interface-handler.sh add $kernel"

# При удалении интерфейса eth1-eth20
SUBSYSTEM=="net", ACTION=="remove", KERNEL=="eth[1-9]", RUN+="/usr/local/bin/modem-interface-handler.sh remove $kernel"
SUBSYSTEM=="net", ACTION=="remove", KERNEL=="eth1[0-9]", RUN+="/usr/local/bin/modem-interface-handler.sh remove $kernel"
SUBSYSTEM=="net", ACTION=="remove", KERNEL=="eth20", RUN+="/usr/local/bin/modem-interface-handler.sh remove $kernel"

# Правила для usb интерфейсов (usb0-usb20)

# При добавлении интерфейса usb0-usb20
SUBSYSTEM=="net", ACTION=="add", KERNEL=="usb[0-9]", RUN+="/usr/local/bin/modem-interface-handler.sh add $kernel"
SUBSYSTEM=="net", ACTION=="add", KERNEL=="usb1[0-9]", RUN+="/usr/local/bin/modem-interface-handler.sh add $kernel"
SUBSYSTEM=="net", ACTION=="add", KERNEL=="usb20", RUN+="/usr/local/bin/modem-interface-handler.sh add $kernel"

# При удалении интерфейса usb0-usb20
SUBSYSTEM=="net", ACTION=="remove", KERNEL=="usb[0-9]", RUN+="/usr/local/bin/modem-interface-handler.sh remove $kernel"
SUBSYSTEM=="net", ACTION=="remove", KERNEL=="usb1[0-9]", RUN+="/usr/local/bin/modem-interface-handler.sh remove $kernel"
SUBSYSTEM=="net", ACTION=="remove", KERNEL=="usb20", RUN+="/usr/local/bin/modem-interface-handler.sh remove $kernel"
EOF

    chmod 644 "$UDEV_RULES_FILE"
    log_info "Udev правила созданы: $UDEV_RULES_FILE"
}

# Перезагрузка udev правил
reload_udev_rules() {
    log_info "Перезагрузка udev правил..."

    udevadm control --reload-rules
    udevadm trigger --subsystem-match=net

    log_info "Udev правила перезагружены"
}

# Создание директории для логов
create_log_directory() {
    local log_dir="/var/log"

    if [ ! -d "$log_dir" ]; then
        mkdir -p "$log_dir"
        log_info "Создана директория для логов: $log_dir"
    fi

    # Создаём пустой лог-файл если не существует
    local log_file="/var/log/modem-handler.log"
    if [ ! -f "$log_file" ]; then
        touch "$log_file"
        chmod 644 "$log_file"
        log_info "Создан лог-файл: $log_file"
    fi
}

# Проверка существующих интерфейсов и их настройка
configure_existing_interfaces() {
    log_info "Проверка существующих интерфейсов модемов..."

    local configured=0

    # Проверяем eth интерфейсы
    for iface in $(ip -o link show | grep -oP 'eth[1-9][0-9]?(?=:)' | grep -E 'eth([1-9]|1[0-9]|20)'); do
        if ip addr show "$iface" | grep -q 'inet '; then
            log_info "Найден активный интерфейс: $iface"
            "$HELPER_SCRIPT" add "$iface" || log_warn "Не удалось настроить $iface"
            ((configured++))
        fi
    done

    # Проверяем usb интерфейсы
    for iface in $(ip -o link show | grep -oP 'usb[0-9][0-9]?(?=:)' | grep -E 'usb([0-9]|1[0-9]|20)'); do
        if ip addr show "$iface" | grep -q 'inet '; then
            log_info "Найден активный интерфейс: $iface"
            "$HELPER_SCRIPT" add "$iface" || log_warn "Не удалось настроить $iface"
            ((configured++))
        fi
    done

    if [ $configured -eq 0 ]; then
        log_warn "Активные интерфейсы модемов не найдены"
        log_info "Интерфейсы будут настроены автоматически при их появлении"
    else
        log_info "Настроено интерфейсов: $configured"
    fi
}

# Главная функция
main() {
    log_info "Начало настройки udev правил..."

    check_root
    install_helper_script
    create_udev_rules
    create_log_directory
    reload_udev_rules

    log_info ""
    log_info "Udev правила установлены и активированы!"
    log_info ""
    log_info "Теперь при подключении модемов будет автоматически:"
    log_info "  1. Настраиваться маршрутизация через отдельные таблицы"
    log_info "  2. Обновляться конфигурация 3proxy"
    log_info "  3. Перезапускаться 3proxy для применения изменений"
    log_info ""

    # Спрашиваем пользователя, хочет ли он настроить существующие интерфейсы
    read -p "Настроить существующие интерфейсы сейчас? (Y/n): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Nn]$ ]]; then
        configure_existing_interfaces
    else
        log_info "Пропуск настройки существующих интерфейсов"
    fi

    log_info ""
    log_info "Проверить логи можно командой:"
    log_info "  tail -f /var/log/modem-handler.log"
}

main "$@"
